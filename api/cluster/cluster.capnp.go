// Code generated by capnpc-go. DO NOT EDIT.

package cluster

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	stream "capnproto.org/go/capnp/v3/std/capnp/stream"
	context "context"
	capstore "github.com/wetware/pkg/api/capstore"
	process "github.com/wetware/pkg/api/process"
	strconv "strconv"
)

type Session capnp.Struct

// Session_TypeID is the unique identifier for the type Session.
const Session_TypeID = 0xe0f9f13c918f18fa

func NewSession(s *capnp.Segment) (Session, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Session(st), err
}

func NewRootSession(s *capnp.Segment) (Session, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Session(st), err
}

func ReadRootSession(msg *capnp.Message) (Session, error) {
	root, err := msg.Root()
	return Session(root.Struct()), err
}

func (s Session) String() string {
	str, _ := text.Marshal(0xe0f9f13c918f18fa, capnp.Struct(s))
	return str
}

func (s Session) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Session) DecodeFromPtr(p capnp.Ptr) Session {
	return Session(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Session) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Session) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Session) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Session) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Session) View() View {
	p, _ := capnp.Struct(s).Ptr(0)
	return View(p.Interface().Client())
}

func (s Session) HasView() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Session) SetView(v View) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s Session) Exec() process.Executor {
	p, _ := capnp.Struct(s).Ptr(1)
	return process.Executor(p.Interface().Client())
}

func (s Session) HasExec() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Session) SetExec(v process.Executor) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(1, in.ToPtr())
}

func (s Session) CapStore() capstore.CapStore {
	p, _ := capnp.Struct(s).Ptr(2)
	return capstore.CapStore(p.Interface().Client())
}

func (s Session) HasCapStore() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Session) SetCapStore(v capstore.CapStore) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(2, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(2, in.ToPtr())
}

// Session_List is a list of Session.
type Session_List = capnp.StructList[Session]

// NewSession creates a new list of Session.
func NewSession_List(s *capnp.Segment, sz int32) (Session_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[Session](l), err
}

// Session_Future is a wrapper for a Session promised by a client call.
type Session_Future struct{ *capnp.Future }

func (f Session_Future) Struct() (Session, error) {
	p, err := f.Future.Ptr()
	return Session(p.Struct()), err
}
func (p Session_Future) View() View {
	return View(p.Future.Field(0, nil).Client())
}

func (p Session_Future) Exec() process.Executor {
	return process.Executor(p.Future.Field(1, nil).Client())
}

func (p Session_Future) CapStore() capstore.CapStore {
	return capstore.CapStore(p.Future.Field(2, nil).Client())
}

type Signer capnp.Client

// Signer_TypeID is the unique identifier for the type Signer.
const Signer_TypeID = 0xf1f2e144cec1f2bc

func (c Signer) Sign(ctx context.Context, params func(Signer_sign_Params) error) (Signer_sign_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf1f2e144cec1f2bc,
			MethodID:      0,
			InterfaceName: "cluster.capnp:Signer",
			MethodName:    "sign",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Signer_sign_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Signer_sign_Results_Future{Future: ans.Future()}, release

}

func (c Signer) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Signer) String() string {
	return "Signer(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Signer) AddRef() Signer {
	return Signer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Signer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Signer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Signer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Signer) DecodeFromPtr(p capnp.Ptr) Signer {
	return Signer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Signer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Signer) IsSame(other Signer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Signer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Signer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Signer_Server is a Signer with a local implementation.
type Signer_Server interface {
	Sign(context.Context, Signer_sign) error
}

// Signer_NewServer creates a new Server from an implementation of Signer_Server.
func Signer_NewServer(s Signer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Signer_Methods(nil, s), s, c)
}

// Signer_ServerToClient creates a new Client from an implementation of Signer_Server.
// The caller is responsible for calling Release on the returned Client.
func Signer_ServerToClient(s Signer_Server) Signer {
	return Signer(capnp.NewClient(Signer_NewServer(s)))
}

// Signer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Signer_Methods(methods []server.Method, s Signer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf1f2e144cec1f2bc,
			MethodID:      0,
			InterfaceName: "cluster.capnp:Signer",
			MethodName:    "sign",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Sign(ctx, Signer_sign{call})
		},
	})

	return methods
}

// Signer_sign holds the state for a server call to Signer.sign.
// See server.Call for documentation.
type Signer_sign struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Signer_sign) Args() Signer_sign_Params {
	return Signer_sign_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Signer_sign) AllocResults() (Signer_sign_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Signer_sign_Results(r), err
}

// Signer_List is a list of Signer.
type Signer_List = capnp.CapList[Signer]

// NewSigner creates a new list of Signer.
func NewSigner_List(s *capnp.Segment, sz int32) (Signer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Signer](l), err
}

type Signer_sign_Params capnp.Struct

// Signer_sign_Params_TypeID is the unique identifier for the type Signer_sign_Params.
const Signer_sign_Params_TypeID = 0xb2250c16d3064727

func NewSigner_sign_Params(s *capnp.Segment) (Signer_sign_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Signer_sign_Params(st), err
}

func NewRootSigner_sign_Params(s *capnp.Segment) (Signer_sign_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Signer_sign_Params(st), err
}

func ReadRootSigner_sign_Params(msg *capnp.Message) (Signer_sign_Params, error) {
	root, err := msg.Root()
	return Signer_sign_Params(root.Struct()), err
}

func (s Signer_sign_Params) String() string {
	str, _ := text.Marshal(0xb2250c16d3064727, capnp.Struct(s))
	return str
}

func (s Signer_sign_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Signer_sign_Params) DecodeFromPtr(p capnp.Ptr) Signer_sign_Params {
	return Signer_sign_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Signer_sign_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Signer_sign_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Signer_sign_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Signer_sign_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Signer_sign_Params) Challenge() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Signer_sign_Params) HasChallenge() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Signer_sign_Params) SetChallenge(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// Signer_sign_Params_List is a list of Signer_sign_Params.
type Signer_sign_Params_List = capnp.StructList[Signer_sign_Params]

// NewSigner_sign_Params creates a new list of Signer_sign_Params.
func NewSigner_sign_Params_List(s *capnp.Segment, sz int32) (Signer_sign_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Signer_sign_Params](l), err
}

// Signer_sign_Params_Future is a wrapper for a Signer_sign_Params promised by a client call.
type Signer_sign_Params_Future struct{ *capnp.Future }

func (f Signer_sign_Params_Future) Struct() (Signer_sign_Params, error) {
	p, err := f.Future.Ptr()
	return Signer_sign_Params(p.Struct()), err
}

type Signer_sign_Results capnp.Struct

// Signer_sign_Results_TypeID is the unique identifier for the type Signer_sign_Results.
const Signer_sign_Results_TypeID = 0xf00b0072c6dcfae7

func NewSigner_sign_Results(s *capnp.Segment) (Signer_sign_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Signer_sign_Results(st), err
}

func NewRootSigner_sign_Results(s *capnp.Segment) (Signer_sign_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Signer_sign_Results(st), err
}

func ReadRootSigner_sign_Results(msg *capnp.Message) (Signer_sign_Results, error) {
	root, err := msg.Root()
	return Signer_sign_Results(root.Struct()), err
}

func (s Signer_sign_Results) String() string {
	str, _ := text.Marshal(0xf00b0072c6dcfae7, capnp.Struct(s))
	return str
}

func (s Signer_sign_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Signer_sign_Results) DecodeFromPtr(p capnp.Ptr) Signer_sign_Results {
	return Signer_sign_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Signer_sign_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Signer_sign_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Signer_sign_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Signer_sign_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Signer_sign_Results) Signed() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Signer_sign_Results) HasSigned() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Signer_sign_Results) SetSigned(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// Signer_sign_Results_List is a list of Signer_sign_Results.
type Signer_sign_Results_List = capnp.StructList[Signer_sign_Results]

// NewSigner_sign_Results creates a new list of Signer_sign_Results.
func NewSigner_sign_Results_List(s *capnp.Segment, sz int32) (Signer_sign_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Signer_sign_Results](l), err
}

// Signer_sign_Results_Future is a wrapper for a Signer_sign_Results promised by a client call.
type Signer_sign_Results_Future struct{ *capnp.Future }

func (f Signer_sign_Results_Future) Struct() (Signer_sign_Results, error) {
	p, err := f.Future.Ptr()
	return Signer_sign_Results(p.Struct()), err
}

type Terminal capnp.Client

// Terminal_TypeID is the unique identifier for the type Terminal.
const Terminal_TypeID = 0xd69d5c8bc70128bc

func (c Terminal) Login(ctx context.Context, params func(Terminal_login_Params) error) (Terminal_login_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xd69d5c8bc70128bc,
			MethodID:      0,
			InterfaceName: "cluster.capnp:Terminal",
			MethodName:    "login",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Terminal_login_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Terminal_login_Results_Future{Future: ans.Future()}, release

}

func (c Terminal) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Terminal) String() string {
	return "Terminal(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Terminal) AddRef() Terminal {
	return Terminal(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Terminal) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Terminal) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Terminal) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Terminal) DecodeFromPtr(p capnp.Ptr) Terminal {
	return Terminal(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Terminal) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Terminal) IsSame(other Terminal) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Terminal) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Terminal) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Terminal_Server is a Terminal with a local implementation.
type Terminal_Server interface {
	Login(context.Context, Terminal_login) error
}

// Terminal_NewServer creates a new Server from an implementation of Terminal_Server.
func Terminal_NewServer(s Terminal_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Terminal_Methods(nil, s), s, c)
}

// Terminal_ServerToClient creates a new Client from an implementation of Terminal_Server.
// The caller is responsible for calling Release on the returned Client.
func Terminal_ServerToClient(s Terminal_Server) Terminal {
	return Terminal(capnp.NewClient(Terminal_NewServer(s)))
}

// Terminal_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Terminal_Methods(methods []server.Method, s Terminal_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xd69d5c8bc70128bc,
			MethodID:      0,
			InterfaceName: "cluster.capnp:Terminal",
			MethodName:    "login",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Login(ctx, Terminal_login{call})
		},
	})

	return methods
}

// Terminal_login holds the state for a server call to Terminal.login.
// See server.Call for documentation.
type Terminal_login struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Terminal_login) Args() Terminal_login_Params {
	return Terminal_login_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Terminal_login) AllocResults() (Terminal_login_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Terminal_login_Results(r), err
}

// Terminal_List is a list of Terminal.
type Terminal_List = capnp.CapList[Terminal]

// NewTerminal creates a new list of Terminal.
func NewTerminal_List(s *capnp.Segment, sz int32) (Terminal_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Terminal](l), err
}

type Terminal_login_Params capnp.Struct

// Terminal_login_Params_TypeID is the unique identifier for the type Terminal_login_Params.
const Terminal_login_Params_TypeID = 0xfa28a083b87f99d0

func NewTerminal_login_Params(s *capnp.Segment) (Terminal_login_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Terminal_login_Params(st), err
}

func NewRootTerminal_login_Params(s *capnp.Segment) (Terminal_login_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Terminal_login_Params(st), err
}

func ReadRootTerminal_login_Params(msg *capnp.Message) (Terminal_login_Params, error) {
	root, err := msg.Root()
	return Terminal_login_Params(root.Struct()), err
}

func (s Terminal_login_Params) String() string {
	str, _ := text.Marshal(0xfa28a083b87f99d0, capnp.Struct(s))
	return str
}

func (s Terminal_login_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Terminal_login_Params) DecodeFromPtr(p capnp.Ptr) Terminal_login_Params {
	return Terminal_login_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Terminal_login_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Terminal_login_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Terminal_login_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Terminal_login_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Terminal_login_Params) Account() Signer {
	p, _ := capnp.Struct(s).Ptr(0)
	return Signer(p.Interface().Client())
}

func (s Terminal_login_Params) HasAccount() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Terminal_login_Params) SetAccount(v Signer) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Terminal_login_Params_List is a list of Terminal_login_Params.
type Terminal_login_Params_List = capnp.StructList[Terminal_login_Params]

// NewTerminal_login_Params creates a new list of Terminal_login_Params.
func NewTerminal_login_Params_List(s *capnp.Segment, sz int32) (Terminal_login_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Terminal_login_Params](l), err
}

// Terminal_login_Params_Future is a wrapper for a Terminal_login_Params promised by a client call.
type Terminal_login_Params_Future struct{ *capnp.Future }

func (f Terminal_login_Params_Future) Struct() (Terminal_login_Params, error) {
	p, err := f.Future.Ptr()
	return Terminal_login_Params(p.Struct()), err
}
func (p Terminal_login_Params_Future) Account() Signer {
	return Signer(p.Future.Field(0, nil).Client())
}

type Terminal_login_Results capnp.Struct

// Terminal_login_Results_TypeID is the unique identifier for the type Terminal_login_Results.
const Terminal_login_Results_TypeID = 0xf09e5b54ee0e67fe

func NewTerminal_login_Results(s *capnp.Segment) (Terminal_login_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Terminal_login_Results(st), err
}

func NewRootTerminal_login_Results(s *capnp.Segment) (Terminal_login_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Terminal_login_Results(st), err
}

func ReadRootTerminal_login_Results(msg *capnp.Message) (Terminal_login_Results, error) {
	root, err := msg.Root()
	return Terminal_login_Results(root.Struct()), err
}

func (s Terminal_login_Results) String() string {
	str, _ := text.Marshal(0xf09e5b54ee0e67fe, capnp.Struct(s))
	return str
}

func (s Terminal_login_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Terminal_login_Results) DecodeFromPtr(p capnp.Ptr) Terminal_login_Results {
	return Terminal_login_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Terminal_login_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Terminal_login_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Terminal_login_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Terminal_login_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Terminal_login_Results) Session() (Session, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Session(p.Struct()), err
}

func (s Terminal_login_Results) HasSession() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Terminal_login_Results) SetSession(v Session) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSession sets the session field to a newly
// allocated Session struct, preferring placement in s's segment.
func (s Terminal_login_Results) NewSession() (Session, error) {
	ss, err := NewSession(capnp.Struct(s).Segment())
	if err != nil {
		return Session{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Terminal_login_Results_List is a list of Terminal_login_Results.
type Terminal_login_Results_List = capnp.StructList[Terminal_login_Results]

// NewTerminal_login_Results creates a new list of Terminal_login_Results.
func NewTerminal_login_Results_List(s *capnp.Segment, sz int32) (Terminal_login_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Terminal_login_Results](l), err
}

// Terminal_login_Results_Future is a wrapper for a Terminal_login_Results promised by a client call.
type Terminal_login_Results_Future struct{ *capnp.Future }

func (f Terminal_login_Results_Future) Struct() (Terminal_login_Results, error) {
	p, err := f.Future.Ptr()
	return Terminal_login_Results(p.Struct()), err
}
func (p Terminal_login_Results_Future) Session() Session_Future {
	return Session_Future{Future: p.Future.Field(0, nil)}
}

type Heartbeat capnp.Struct

// Heartbeat_TypeID is the unique identifier for the type Heartbeat.
const Heartbeat_TypeID = 0xa97471079836f720

func NewHeartbeat(s *capnp.Segment) (Heartbeat, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Heartbeat(st), err
}

func NewRootHeartbeat(s *capnp.Segment) (Heartbeat, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Heartbeat(st), err
}

func ReadRootHeartbeat(msg *capnp.Message) (Heartbeat, error) {
	root, err := msg.Root()
	return Heartbeat(root.Struct()), err
}

func (s Heartbeat) String() string {
	str, _ := text.Marshal(0xa97471079836f720, capnp.Struct(s))
	return str
}

func (s Heartbeat) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Heartbeat) DecodeFromPtr(p capnp.Ptr) Heartbeat {
	return Heartbeat(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Heartbeat) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Heartbeat) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Heartbeat) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Heartbeat) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Heartbeat) Ttl() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Heartbeat) SetTtl(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s Heartbeat) Server() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s Heartbeat) SetServer(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s Heartbeat) Host() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Heartbeat) HasHost() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Heartbeat) HostBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Heartbeat) SetHost(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Heartbeat) Meta() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s Heartbeat) HasMeta() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Heartbeat) SetMeta(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewMeta sets the meta field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Heartbeat) NewMeta(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Heartbeat_List is a list of Heartbeat.
type Heartbeat_List = capnp.StructList[Heartbeat]

// NewHeartbeat creates a new list of Heartbeat.
func NewHeartbeat_List(s *capnp.Segment, sz int32) (Heartbeat_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Heartbeat](l), err
}

// Heartbeat_Future is a wrapper for a Heartbeat promised by a client call.
type Heartbeat_Future struct{ *capnp.Future }

func (f Heartbeat_Future) Struct() (Heartbeat, error) {
	p, err := f.Future.Ptr()
	return Heartbeat(p.Struct()), err
}

type View capnp.Client

// View_TypeID is the unique identifier for the type View.
const View_TypeID = 0x8a1df0335afc249a

func (c View) Lookup(ctx context.Context, params func(View_lookup_Params) error) (View_lookup_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      0,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "lookup",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(View_lookup_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return View_lookup_Results_Future{Future: ans.Future()}, release

}

func (c View) Iter(ctx context.Context, params func(View_iter_Params) error) (View_iter_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      1,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "iter",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 3}
		s.PlaceArgs = func(s capnp.Struct) error { return params(View_iter_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return View_iter_Results_Future{Future: ans.Future()}, release

}

func (c View) Reverse(ctx context.Context, params func(View_reverse_Params) error) (View_reverse_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      2,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "reverse",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(View_reverse_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return View_reverse_Results_Future{Future: ans.Future()}, release

}

func (c View) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c View) String() string {
	return "View(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c View) AddRef() View {
	return View(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c View) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c View) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c View) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (View) DecodeFromPtr(p capnp.Ptr) View {
	return View(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c View) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c View) IsSame(other View) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c View) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c View) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A View_Server is a View with a local implementation.
type View_Server interface {
	Lookup(context.Context, View_lookup) error

	Iter(context.Context, View_iter) error

	Reverse(context.Context, View_reverse) error
}

// View_NewServer creates a new Server from an implementation of View_Server.
func View_NewServer(s View_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(View_Methods(nil, s), s, c)
}

// View_ServerToClient creates a new Client from an implementation of View_Server.
// The caller is responsible for calling Release on the returned Client.
func View_ServerToClient(s View_Server) View {
	return View(capnp.NewClient(View_NewServer(s)))
}

// View_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func View_Methods(methods []server.Method, s View_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 3)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      0,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "lookup",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Lookup(ctx, View_lookup{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      1,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "iter",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Iter(ctx, View_iter{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      2,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "reverse",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Reverse(ctx, View_reverse{call})
		},
	})

	return methods
}

// View_lookup holds the state for a server call to View.lookup.
// See server.Call for documentation.
type View_lookup struct {
	*server.Call
}

// Args returns the call's arguments.
func (c View_lookup) Args() View_lookup_Params {
	return View_lookup_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c View_lookup) AllocResults() (View_lookup_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_lookup_Results(r), err
}

// View_iter holds the state for a server call to View.iter.
// See server.Call for documentation.
type View_iter struct {
	*server.Call
}

// Args returns the call's arguments.
func (c View_iter) Args() View_iter_Params {
	return View_iter_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c View_iter) AllocResults() (View_iter_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return View_iter_Results(r), err
}

// View_reverse holds the state for a server call to View.reverse.
// See server.Call for documentation.
type View_reverse struct {
	*server.Call
}

// Args returns the call's arguments.
func (c View_reverse) Args() View_reverse_Params {
	return View_reverse_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c View_reverse) AllocResults() (View_reverse_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_reverse_Results(r), err
}

// View_List is a list of View.
type View_List = capnp.CapList[View]

// NewView creates a new list of View.
func NewView_List(s *capnp.Segment, sz int32) (View_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[View](l), err
}

type View_Handler capnp.Client

// View_Handler_TypeID is the unique identifier for the type View_Handler.
const View_Handler_TypeID = 0xee93a663b2a23c03

func (c View_Handler) Recv(ctx context.Context, params func(View_Handler_recv_Params) error) error {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xee93a663b2a23c03,
			MethodID:      0,
			InterfaceName: "cluster.capnp:View.Handler",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(View_Handler_recv_Params(s)) }
	}

	return capnp.Client(c).SendStreamCall(ctx, s)

}

func (c View_Handler) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c View_Handler) String() string {
	return "View_Handler(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c View_Handler) AddRef() View_Handler {
	return View_Handler(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c View_Handler) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c View_Handler) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c View_Handler) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (View_Handler) DecodeFromPtr(p capnp.Ptr) View_Handler {
	return View_Handler(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c View_Handler) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c View_Handler) IsSame(other View_Handler) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c View_Handler) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c View_Handler) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A View_Handler_Server is a View_Handler with a local implementation.
type View_Handler_Server interface {
	Recv(context.Context, View_Handler_recv) error
}

// View_Handler_NewServer creates a new Server from an implementation of View_Handler_Server.
func View_Handler_NewServer(s View_Handler_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(View_Handler_Methods(nil, s), s, c)
}

// View_Handler_ServerToClient creates a new Client from an implementation of View_Handler_Server.
// The caller is responsible for calling Release on the returned Client.
func View_Handler_ServerToClient(s View_Handler_Server) View_Handler {
	return View_Handler(capnp.NewClient(View_Handler_NewServer(s)))
}

// View_Handler_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func View_Handler_Methods(methods []server.Method, s View_Handler_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xee93a663b2a23c03,
			MethodID:      0,
			InterfaceName: "cluster.capnp:View.Handler",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, View_Handler_recv{call})
		},
	})

	return methods
}

// View_Handler_recv holds the state for a server call to View_Handler.recv.
// See server.Call for documentation.
type View_Handler_recv struct {
	*server.Call
}

// Args returns the call's arguments.
func (c View_Handler_recv) Args() View_Handler_recv_Params {
	return View_Handler_recv_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c View_Handler_recv) AllocResults() (stream.StreamResult, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return stream.StreamResult(r), err
}

// View_Handler_List is a list of View_Handler.
type View_Handler_List = capnp.CapList[View_Handler]

// NewView_Handler creates a new list of View_Handler.
func NewView_Handler_List(s *capnp.Segment, sz int32) (View_Handler_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[View_Handler](l), err
}

type View_Handler_recv_Params capnp.Struct

// View_Handler_recv_Params_TypeID is the unique identifier for the type View_Handler_recv_Params.
const View_Handler_recv_Params_TypeID = 0x8eb96dceb6a99ebd

func NewView_Handler_recv_Params(s *capnp.Segment) (View_Handler_recv_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_Handler_recv_Params(st), err
}

func NewRootView_Handler_recv_Params(s *capnp.Segment) (View_Handler_recv_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_Handler_recv_Params(st), err
}

func ReadRootView_Handler_recv_Params(msg *capnp.Message) (View_Handler_recv_Params, error) {
	root, err := msg.Root()
	return View_Handler_recv_Params(root.Struct()), err
}

func (s View_Handler_recv_Params) String() string {
	str, _ := text.Marshal(0x8eb96dceb6a99ebd, capnp.Struct(s))
	return str
}

func (s View_Handler_recv_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_Handler_recv_Params) DecodeFromPtr(p capnp.Ptr) View_Handler_recv_Params {
	return View_Handler_recv_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_Handler_recv_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_Handler_recv_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_Handler_recv_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_Handler_recv_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_Handler_recv_Params) Record() (View_Record, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return View_Record(p.Struct()), err
}

func (s View_Handler_recv_Params) HasRecord() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Handler_recv_Params) SetRecord(v View_Record) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewRecord sets the record field to a newly
// allocated View_Record struct, preferring placement in s's segment.
func (s View_Handler_recv_Params) NewRecord() (View_Record, error) {
	ss, err := NewView_Record(capnp.Struct(s).Segment())
	if err != nil {
		return View_Record{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_Handler_recv_Params_List is a list of View_Handler_recv_Params.
type View_Handler_recv_Params_List = capnp.StructList[View_Handler_recv_Params]

// NewView_Handler_recv_Params creates a new list of View_Handler_recv_Params.
func NewView_Handler_recv_Params_List(s *capnp.Segment, sz int32) (View_Handler_recv_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[View_Handler_recv_Params](l), err
}

// View_Handler_recv_Params_Future is a wrapper for a View_Handler_recv_Params promised by a client call.
type View_Handler_recv_Params_Future struct{ *capnp.Future }

func (f View_Handler_recv_Params_Future) Struct() (View_Handler_recv_Params, error) {
	p, err := f.Future.Ptr()
	return View_Handler_recv_Params(p.Struct()), err
}
func (p View_Handler_recv_Params_Future) Record() View_Record_Future {
	return View_Record_Future{Future: p.Future.Field(0, nil)}
}

type View_Selector capnp.Struct
type View_Selector_Which uint16

const (
	View_Selector_Which_all   View_Selector_Which = 0
	View_Selector_Which_match View_Selector_Which = 1
	View_Selector_Which_from  View_Selector_Which = 2
)

func (w View_Selector_Which) String() string {
	const s = "allmatchfrom"
	switch w {
	case View_Selector_Which_all:
		return s[0:3]
	case View_Selector_Which_match:
		return s[3:8]
	case View_Selector_Which_from:
		return s[8:12]

	}
	return "View_Selector_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// View_Selector_TypeID is the unique identifier for the type View_Selector.
const View_Selector_TypeID = 0xb2029ff7b712d18a

func NewView_Selector(s *capnp.Segment) (View_Selector, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_Selector(st), err
}

func NewRootView_Selector(s *capnp.Segment) (View_Selector, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_Selector(st), err
}

func ReadRootView_Selector(msg *capnp.Message) (View_Selector, error) {
	root, err := msg.Root()
	return View_Selector(root.Struct()), err
}

func (s View_Selector) String() string {
	str, _ := text.Marshal(0xb2029ff7b712d18a, capnp.Struct(s))
	return str
}

func (s View_Selector) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_Selector) DecodeFromPtr(p capnp.Ptr) View_Selector {
	return View_Selector(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_Selector) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s View_Selector) Which() View_Selector_Which {
	return View_Selector_Which(capnp.Struct(s).Uint16(0))
}
func (s View_Selector) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_Selector) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_Selector) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_Selector) SetAll() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s View_Selector) Match() (View_Index, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != match")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return View_Index(p.Struct()), err
}

func (s View_Selector) HasMatch() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Selector) SetMatch(v View_Index) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewMatch sets the match field to a newly
// allocated View_Index struct, preferring placement in s's segment.
func (s View_Selector) NewMatch() (View_Index, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewView_Index(capnp.Struct(s).Segment())
	if err != nil {
		return View_Index{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s View_Selector) From() (View_Index, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != from")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return View_Index(p.Struct()), err
}

func (s View_Selector) HasFrom() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Selector) SetFrom(v View_Index) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewFrom sets the from field to a newly
// allocated View_Index struct, preferring placement in s's segment.
func (s View_Selector) NewFrom() (View_Index, error) {
	capnp.Struct(s).SetUint16(0, 2)
	ss, err := NewView_Index(capnp.Struct(s).Segment())
	if err != nil {
		return View_Index{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_Selector_List is a list of View_Selector.
type View_Selector_List = capnp.StructList[View_Selector]

// NewView_Selector creates a new list of View_Selector.
func NewView_Selector_List(s *capnp.Segment, sz int32) (View_Selector_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[View_Selector](l), err
}

// View_Selector_Future is a wrapper for a View_Selector promised by a client call.
type View_Selector_Future struct{ *capnp.Future }

func (f View_Selector_Future) Struct() (View_Selector, error) {
	p, err := f.Future.Ptr()
	return View_Selector(p.Struct()), err
}
func (p View_Selector_Future) Match() View_Index_Future {
	return View_Index_Future{Future: p.Future.Field(0, nil)}
}
func (p View_Selector_Future) From() View_Index_Future {
	return View_Index_Future{Future: p.Future.Field(0, nil)}
}

type View_Constraint capnp.Struct
type View_Constraint_Which uint16

const (
	View_Constraint_Which_limit View_Constraint_Which = 0
	View_Constraint_Which_to    View_Constraint_Which = 1
)

func (w View_Constraint_Which) String() string {
	const s = "limitto"
	switch w {
	case View_Constraint_Which_limit:
		return s[0:5]
	case View_Constraint_Which_to:
		return s[5:7]

	}
	return "View_Constraint_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// View_Constraint_TypeID is the unique identifier for the type View_Constraint.
const View_Constraint_TypeID = 0xab133d2062f6cc53

func NewView_Constraint(s *capnp.Segment) (View_Constraint, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return View_Constraint(st), err
}

func NewRootView_Constraint(s *capnp.Segment) (View_Constraint, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return View_Constraint(st), err
}

func ReadRootView_Constraint(msg *capnp.Message) (View_Constraint, error) {
	root, err := msg.Root()
	return View_Constraint(root.Struct()), err
}

func (s View_Constraint) String() string {
	str, _ := text.Marshal(0xab133d2062f6cc53, capnp.Struct(s))
	return str
}

func (s View_Constraint) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_Constraint) DecodeFromPtr(p capnp.Ptr) View_Constraint {
	return View_Constraint(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_Constraint) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s View_Constraint) Which() View_Constraint_Which {
	return View_Constraint_Which(capnp.Struct(s).Uint16(8))
}
func (s View_Constraint) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_Constraint) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_Constraint) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_Constraint) Limit() uint64 {
	if capnp.Struct(s).Uint16(8) != 0 {
		panic("Which() != limit")
	}
	return capnp.Struct(s).Uint64(0)
}

func (s View_Constraint) SetLimit(v uint64) {
	capnp.Struct(s).SetUint16(8, 0)
	capnp.Struct(s).SetUint64(0, v)
}

func (s View_Constraint) To() (View_Index, error) {
	if capnp.Struct(s).Uint16(8) != 1 {
		panic("Which() != to")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return View_Index(p.Struct()), err
}

func (s View_Constraint) HasTo() bool {
	if capnp.Struct(s).Uint16(8) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Constraint) SetTo(v View_Index) error {
	capnp.Struct(s).SetUint16(8, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewTo sets the to field to a newly
// allocated View_Index struct, preferring placement in s's segment.
func (s View_Constraint) NewTo() (View_Index, error) {
	capnp.Struct(s).SetUint16(8, 1)
	ss, err := NewView_Index(capnp.Struct(s).Segment())
	if err != nil {
		return View_Index{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_Constraint_List is a list of View_Constraint.
type View_Constraint_List = capnp.StructList[View_Constraint]

// NewView_Constraint creates a new list of View_Constraint.
func NewView_Constraint_List(s *capnp.Segment, sz int32) (View_Constraint_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[View_Constraint](l), err
}

// View_Constraint_Future is a wrapper for a View_Constraint promised by a client call.
type View_Constraint_Future struct{ *capnp.Future }

func (f View_Constraint_Future) Struct() (View_Constraint, error) {
	p, err := f.Future.Ptr()
	return View_Constraint(p.Struct()), err
}
func (p View_Constraint_Future) To() View_Index_Future {
	return View_Index_Future{Future: p.Future.Field(0, nil)}
}

type View_Index capnp.Struct
type View_Index_Which uint16

const (
	View_Index_Which_peer   View_Index_Which = 0
	View_Index_Which_server View_Index_Which = 1
	View_Index_Which_host   View_Index_Which = 2
	View_Index_Which_meta   View_Index_Which = 3
)

func (w View_Index_Which) String() string {
	const s = "peerserverhostmeta"
	switch w {
	case View_Index_Which_peer:
		return s[0:4]
	case View_Index_Which_server:
		return s[4:10]
	case View_Index_Which_host:
		return s[10:14]
	case View_Index_Which_meta:
		return s[14:18]

	}
	return "View_Index_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// View_Index_TypeID is the unique identifier for the type View_Index.
const View_Index_TypeID = 0xcc2d04cc26d4f6a5

func NewView_Index(s *capnp.Segment) (View_Index, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_Index(st), err
}

func NewRootView_Index(s *capnp.Segment) (View_Index, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_Index(st), err
}

func ReadRootView_Index(msg *capnp.Message) (View_Index, error) {
	root, err := msg.Root()
	return View_Index(root.Struct()), err
}

func (s View_Index) String() string {
	str, _ := text.Marshal(0xcc2d04cc26d4f6a5, capnp.Struct(s))
	return str
}

func (s View_Index) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_Index) DecodeFromPtr(p capnp.Ptr) View_Index {
	return View_Index(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_Index) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s View_Index) Which() View_Index_Which {
	return View_Index_Which(capnp.Struct(s).Uint16(2))
}
func (s View_Index) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_Index) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_Index) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_Index) Prefix() bool {
	return capnp.Struct(s).Bit(0)
}

func (s View_Index) SetPrefix(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

func (s View_Index) Peer() (string, error) {
	if capnp.Struct(s).Uint16(2) != 0 {
		panic("Which() != peer")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s View_Index) HasPeer() bool {
	if capnp.Struct(s).Uint16(2) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Index) PeerBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s View_Index) SetPeer(v string) error {
	capnp.Struct(s).SetUint16(2, 0)
	return capnp.Struct(s).SetText(0, v)
}

func (s View_Index) Server() ([]byte, error) {
	if capnp.Struct(s).Uint16(2) != 1 {
		panic("Which() != server")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s View_Index) HasServer() bool {
	if capnp.Struct(s).Uint16(2) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Index) SetServer(v []byte) error {
	capnp.Struct(s).SetUint16(2, 1)
	return capnp.Struct(s).SetData(0, v)
}

func (s View_Index) Host() (string, error) {
	if capnp.Struct(s).Uint16(2) != 2 {
		panic("Which() != host")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s View_Index) HasHost() bool {
	if capnp.Struct(s).Uint16(2) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Index) HostBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s View_Index) SetHost(v string) error {
	capnp.Struct(s).SetUint16(2, 2)
	return capnp.Struct(s).SetText(0, v)
}

func (s View_Index) Meta() (string, error) {
	if capnp.Struct(s).Uint16(2) != 3 {
		panic("Which() != meta")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s View_Index) HasMeta() bool {
	if capnp.Struct(s).Uint16(2) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Index) MetaBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s View_Index) SetMeta(v string) error {
	capnp.Struct(s).SetUint16(2, 3)
	return capnp.Struct(s).SetText(0, v)
}

// View_Index_List is a list of View_Index.
type View_Index_List = capnp.StructList[View_Index]

// NewView_Index creates a new list of View_Index.
func NewView_Index_List(s *capnp.Segment, sz int32) (View_Index_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[View_Index](l), err
}

// View_Index_Future is a wrapper for a View_Index promised by a client call.
type View_Index_Future struct{ *capnp.Future }

func (f View_Index_Future) Struct() (View_Index, error) {
	p, err := f.Future.Ptr()
	return View_Index(p.Struct()), err
}

type View_Record capnp.Struct

// View_Record_TypeID is the unique identifier for the type View_Record.
const View_Record_TypeID = 0xcdcf42beb2537d20

func NewView_Record(s *capnp.Segment) (View_Record, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return View_Record(st), err
}

func NewRootView_Record(s *capnp.Segment) (View_Record, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return View_Record(st), err
}

func ReadRootView_Record(msg *capnp.Message) (View_Record, error) {
	root, err := msg.Root()
	return View_Record(root.Struct()), err
}

func (s View_Record) String() string {
	str, _ := text.Marshal(0xcdcf42beb2537d20, capnp.Struct(s))
	return str
}

func (s View_Record) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_Record) DecodeFromPtr(p capnp.Ptr) View_Record {
	return View_Record(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_Record) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_Record) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_Record) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_Record) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_Record) Peer() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s View_Record) HasPeer() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Record) PeerBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s View_Record) SetPeer(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s View_Record) Server() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s View_Record) SetServer(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s View_Record) Seq() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s View_Record) SetSeq(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s View_Record) Heartbeat() (Heartbeat, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Heartbeat(p.Struct()), err
}

func (s View_Record) HasHeartbeat() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s View_Record) SetHeartbeat(v Heartbeat) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewHeartbeat sets the heartbeat field to a newly
// allocated Heartbeat struct, preferring placement in s's segment.
func (s View_Record) NewHeartbeat() (Heartbeat, error) {
	ss, err := NewHeartbeat(capnp.Struct(s).Segment())
	if err != nil {
		return Heartbeat{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_Record_List is a list of View_Record.
type View_Record_List = capnp.StructList[View_Record]

// NewView_Record creates a new list of View_Record.
func NewView_Record_List(s *capnp.Segment, sz int32) (View_Record_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[View_Record](l), err
}

// View_Record_Future is a wrapper for a View_Record promised by a client call.
type View_Record_Future struct{ *capnp.Future }

func (f View_Record_Future) Struct() (View_Record, error) {
	p, err := f.Future.Ptr()
	return View_Record(p.Struct()), err
}
func (p View_Record_Future) Heartbeat() Heartbeat_Future {
	return Heartbeat_Future{Future: p.Future.Field(1, nil)}
}

type View_MaybeRecord capnp.Struct
type View_MaybeRecord_Which uint16

const (
	View_MaybeRecord_Which_nothing View_MaybeRecord_Which = 0
	View_MaybeRecord_Which_just    View_MaybeRecord_Which = 1
)

func (w View_MaybeRecord_Which) String() string {
	const s = "nothingjust"
	switch w {
	case View_MaybeRecord_Which_nothing:
		return s[0:7]
	case View_MaybeRecord_Which_just:
		return s[7:11]

	}
	return "View_MaybeRecord_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// View_MaybeRecord_TypeID is the unique identifier for the type View_MaybeRecord.
const View_MaybeRecord_TypeID = 0xd6a4f298bc0e2304

func NewView_MaybeRecord(s *capnp.Segment) (View_MaybeRecord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_MaybeRecord(st), err
}

func NewRootView_MaybeRecord(s *capnp.Segment) (View_MaybeRecord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_MaybeRecord(st), err
}

func ReadRootView_MaybeRecord(msg *capnp.Message) (View_MaybeRecord, error) {
	root, err := msg.Root()
	return View_MaybeRecord(root.Struct()), err
}

func (s View_MaybeRecord) String() string {
	str, _ := text.Marshal(0xd6a4f298bc0e2304, capnp.Struct(s))
	return str
}

func (s View_MaybeRecord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_MaybeRecord) DecodeFromPtr(p capnp.Ptr) View_MaybeRecord {
	return View_MaybeRecord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_MaybeRecord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s View_MaybeRecord) Which() View_MaybeRecord_Which {
	return View_MaybeRecord_Which(capnp.Struct(s).Uint16(0))
}
func (s View_MaybeRecord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_MaybeRecord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_MaybeRecord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_MaybeRecord) SetNothing() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s View_MaybeRecord) Just() (View_Record, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != just")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return View_Record(p.Struct()), err
}

func (s View_MaybeRecord) HasJust() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_MaybeRecord) SetJust(v View_Record) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewJust sets the just field to a newly
// allocated View_Record struct, preferring placement in s's segment.
func (s View_MaybeRecord) NewJust() (View_Record, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewView_Record(capnp.Struct(s).Segment())
	if err != nil {
		return View_Record{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_MaybeRecord_List is a list of View_MaybeRecord.
type View_MaybeRecord_List = capnp.StructList[View_MaybeRecord]

// NewView_MaybeRecord creates a new list of View_MaybeRecord.
func NewView_MaybeRecord_List(s *capnp.Segment, sz int32) (View_MaybeRecord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[View_MaybeRecord](l), err
}

// View_MaybeRecord_Future is a wrapper for a View_MaybeRecord promised by a client call.
type View_MaybeRecord_Future struct{ *capnp.Future }

func (f View_MaybeRecord_Future) Struct() (View_MaybeRecord, error) {
	p, err := f.Future.Ptr()
	return View_MaybeRecord(p.Struct()), err
}
func (p View_MaybeRecord_Future) Just() View_Record_Future {
	return View_Record_Future{Future: p.Future.Field(0, nil)}
}

type View_lookup_Params capnp.Struct

// View_lookup_Params_TypeID is the unique identifier for the type View_lookup_Params.
const View_lookup_Params_TypeID = 0xd929e054f82b286c

func NewView_lookup_Params(s *capnp.Segment) (View_lookup_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return View_lookup_Params(st), err
}

func NewRootView_lookup_Params(s *capnp.Segment) (View_lookup_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return View_lookup_Params(st), err
}

func ReadRootView_lookup_Params(msg *capnp.Message) (View_lookup_Params, error) {
	root, err := msg.Root()
	return View_lookup_Params(root.Struct()), err
}

func (s View_lookup_Params) String() string {
	str, _ := text.Marshal(0xd929e054f82b286c, capnp.Struct(s))
	return str
}

func (s View_lookup_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_lookup_Params) DecodeFromPtr(p capnp.Ptr) View_lookup_Params {
	return View_lookup_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_lookup_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_lookup_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_lookup_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_lookup_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_lookup_Params) Selector() (View_Selector, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return View_Selector(p.Struct()), err
}

func (s View_lookup_Params) HasSelector() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_lookup_Params) SetSelector(v View_Selector) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSelector sets the selector field to a newly
// allocated View_Selector struct, preferring placement in s's segment.
func (s View_lookup_Params) NewSelector() (View_Selector, error) {
	ss, err := NewView_Selector(capnp.Struct(s).Segment())
	if err != nil {
		return View_Selector{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s View_lookup_Params) Constraints() (View_Constraint_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return View_Constraint_List(p.List()), err
}

func (s View_lookup_Params) HasConstraints() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s View_lookup_Params) SetConstraints(v View_Constraint_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewConstraints sets the constraints field to a newly
// allocated View_Constraint_List, preferring placement in s's segment.
func (s View_lookup_Params) NewConstraints(n int32) (View_Constraint_List, error) {
	l, err := NewView_Constraint_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return View_Constraint_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// View_lookup_Params_List is a list of View_lookup_Params.
type View_lookup_Params_List = capnp.StructList[View_lookup_Params]

// NewView_lookup_Params creates a new list of View_lookup_Params.
func NewView_lookup_Params_List(s *capnp.Segment, sz int32) (View_lookup_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[View_lookup_Params](l), err
}

// View_lookup_Params_Future is a wrapper for a View_lookup_Params promised by a client call.
type View_lookup_Params_Future struct{ *capnp.Future }

func (f View_lookup_Params_Future) Struct() (View_lookup_Params, error) {
	p, err := f.Future.Ptr()
	return View_lookup_Params(p.Struct()), err
}
func (p View_lookup_Params_Future) Selector() View_Selector_Future {
	return View_Selector_Future{Future: p.Future.Field(0, nil)}
}

type View_lookup_Results capnp.Struct

// View_lookup_Results_TypeID is the unique identifier for the type View_lookup_Results.
const View_lookup_Results_TypeID = 0xe6df611247a8fc13

func NewView_lookup_Results(s *capnp.Segment) (View_lookup_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_lookup_Results(st), err
}

func NewRootView_lookup_Results(s *capnp.Segment) (View_lookup_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_lookup_Results(st), err
}

func ReadRootView_lookup_Results(msg *capnp.Message) (View_lookup_Results, error) {
	root, err := msg.Root()
	return View_lookup_Results(root.Struct()), err
}

func (s View_lookup_Results) String() string {
	str, _ := text.Marshal(0xe6df611247a8fc13, capnp.Struct(s))
	return str
}

func (s View_lookup_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_lookup_Results) DecodeFromPtr(p capnp.Ptr) View_lookup_Results {
	return View_lookup_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_lookup_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_lookup_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_lookup_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_lookup_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_lookup_Results) Result() (View_MaybeRecord, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return View_MaybeRecord(p.Struct()), err
}

func (s View_lookup_Results) HasResult() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_lookup_Results) SetResult(v View_MaybeRecord) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewResult sets the result field to a newly
// allocated View_MaybeRecord struct, preferring placement in s's segment.
func (s View_lookup_Results) NewResult() (View_MaybeRecord, error) {
	ss, err := NewView_MaybeRecord(capnp.Struct(s).Segment())
	if err != nil {
		return View_MaybeRecord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_lookup_Results_List is a list of View_lookup_Results.
type View_lookup_Results_List = capnp.StructList[View_lookup_Results]

// NewView_lookup_Results creates a new list of View_lookup_Results.
func NewView_lookup_Results_List(s *capnp.Segment, sz int32) (View_lookup_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[View_lookup_Results](l), err
}

// View_lookup_Results_Future is a wrapper for a View_lookup_Results promised by a client call.
type View_lookup_Results_Future struct{ *capnp.Future }

func (f View_lookup_Results_Future) Struct() (View_lookup_Results, error) {
	p, err := f.Future.Ptr()
	return View_lookup_Results(p.Struct()), err
}
func (p View_lookup_Results_Future) Result() View_MaybeRecord_Future {
	return View_MaybeRecord_Future{Future: p.Future.Field(0, nil)}
}

type View_iter_Params capnp.Struct

// View_iter_Params_TypeID is the unique identifier for the type View_iter_Params.
const View_iter_Params_TypeID = 0xf495a555c9344000

func NewView_iter_Params(s *capnp.Segment) (View_iter_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return View_iter_Params(st), err
}

func NewRootView_iter_Params(s *capnp.Segment) (View_iter_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return View_iter_Params(st), err
}

func ReadRootView_iter_Params(msg *capnp.Message) (View_iter_Params, error) {
	root, err := msg.Root()
	return View_iter_Params(root.Struct()), err
}

func (s View_iter_Params) String() string {
	str, _ := text.Marshal(0xf495a555c9344000, capnp.Struct(s))
	return str
}

func (s View_iter_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_iter_Params) DecodeFromPtr(p capnp.Ptr) View_iter_Params {
	return View_iter_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_iter_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_iter_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_iter_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_iter_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_iter_Params) Handler() View_Handler {
	p, _ := capnp.Struct(s).Ptr(0)
	return View_Handler(p.Interface().Client())
}

func (s View_iter_Params) HasHandler() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_iter_Params) SetHandler(v View_Handler) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s View_iter_Params) Selector() (View_Selector, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return View_Selector(p.Struct()), err
}

func (s View_iter_Params) HasSelector() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s View_iter_Params) SetSelector(v View_Selector) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewSelector sets the selector field to a newly
// allocated View_Selector struct, preferring placement in s's segment.
func (s View_iter_Params) NewSelector() (View_Selector, error) {
	ss, err := NewView_Selector(capnp.Struct(s).Segment())
	if err != nil {
		return View_Selector{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s View_iter_Params) Constraints() (View_Constraint_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return View_Constraint_List(p.List()), err
}

func (s View_iter_Params) HasConstraints() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s View_iter_Params) SetConstraints(v View_Constraint_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewConstraints sets the constraints field to a newly
// allocated View_Constraint_List, preferring placement in s's segment.
func (s View_iter_Params) NewConstraints(n int32) (View_Constraint_List, error) {
	l, err := NewView_Constraint_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return View_Constraint_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// View_iter_Params_List is a list of View_iter_Params.
type View_iter_Params_List = capnp.StructList[View_iter_Params]

// NewView_iter_Params creates a new list of View_iter_Params.
func NewView_iter_Params_List(s *capnp.Segment, sz int32) (View_iter_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[View_iter_Params](l), err
}

// View_iter_Params_Future is a wrapper for a View_iter_Params promised by a client call.
type View_iter_Params_Future struct{ *capnp.Future }

func (f View_iter_Params_Future) Struct() (View_iter_Params, error) {
	p, err := f.Future.Ptr()
	return View_iter_Params(p.Struct()), err
}
func (p View_iter_Params_Future) Handler() View_Handler {
	return View_Handler(p.Future.Field(0, nil).Client())
}

func (p View_iter_Params_Future) Selector() View_Selector_Future {
	return View_Selector_Future{Future: p.Future.Field(1, nil)}
}

type View_iter_Results capnp.Struct

// View_iter_Results_TypeID is the unique identifier for the type View_iter_Results.
const View_iter_Results_TypeID = 0xe54acc44b61fd7ef

func NewView_iter_Results(s *capnp.Segment) (View_iter_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return View_iter_Results(st), err
}

func NewRootView_iter_Results(s *capnp.Segment) (View_iter_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return View_iter_Results(st), err
}

func ReadRootView_iter_Results(msg *capnp.Message) (View_iter_Results, error) {
	root, err := msg.Root()
	return View_iter_Results(root.Struct()), err
}

func (s View_iter_Results) String() string {
	str, _ := text.Marshal(0xe54acc44b61fd7ef, capnp.Struct(s))
	return str
}

func (s View_iter_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_iter_Results) DecodeFromPtr(p capnp.Ptr) View_iter_Results {
	return View_iter_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_iter_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_iter_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_iter_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_iter_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// View_iter_Results_List is a list of View_iter_Results.
type View_iter_Results_List = capnp.StructList[View_iter_Results]

// NewView_iter_Results creates a new list of View_iter_Results.
func NewView_iter_Results_List(s *capnp.Segment, sz int32) (View_iter_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[View_iter_Results](l), err
}

// View_iter_Results_Future is a wrapper for a View_iter_Results promised by a client call.
type View_iter_Results_Future struct{ *capnp.Future }

func (f View_iter_Results_Future) Struct() (View_iter_Results, error) {
	p, err := f.Future.Ptr()
	return View_iter_Results(p.Struct()), err
}

type View_reverse_Params capnp.Struct

// View_reverse_Params_TypeID is the unique identifier for the type View_reverse_Params.
const View_reverse_Params_TypeID = 0x8b1fd983f1df482d

func NewView_reverse_Params(s *capnp.Segment) (View_reverse_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return View_reverse_Params(st), err
}

func NewRootView_reverse_Params(s *capnp.Segment) (View_reverse_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return View_reverse_Params(st), err
}

func ReadRootView_reverse_Params(msg *capnp.Message) (View_reverse_Params, error) {
	root, err := msg.Root()
	return View_reverse_Params(root.Struct()), err
}

func (s View_reverse_Params) String() string {
	str, _ := text.Marshal(0x8b1fd983f1df482d, capnp.Struct(s))
	return str
}

func (s View_reverse_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_reverse_Params) DecodeFromPtr(p capnp.Ptr) View_reverse_Params {
	return View_reverse_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_reverse_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_reverse_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_reverse_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_reverse_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// View_reverse_Params_List is a list of View_reverse_Params.
type View_reverse_Params_List = capnp.StructList[View_reverse_Params]

// NewView_reverse_Params creates a new list of View_reverse_Params.
func NewView_reverse_Params_List(s *capnp.Segment, sz int32) (View_reverse_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[View_reverse_Params](l), err
}

// View_reverse_Params_Future is a wrapper for a View_reverse_Params promised by a client call.
type View_reverse_Params_Future struct{ *capnp.Future }

func (f View_reverse_Params_Future) Struct() (View_reverse_Params, error) {
	p, err := f.Future.Ptr()
	return View_reverse_Params(p.Struct()), err
}

type View_reverse_Results capnp.Struct

// View_reverse_Results_TypeID is the unique identifier for the type View_reverse_Results.
const View_reverse_Results_TypeID = 0xcc7efefbb528cd6c

func NewView_reverse_Results(s *capnp.Segment) (View_reverse_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_reverse_Results(st), err
}

func NewRootView_reverse_Results(s *capnp.Segment) (View_reverse_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_reverse_Results(st), err
}

func ReadRootView_reverse_Results(msg *capnp.Message) (View_reverse_Results, error) {
	root, err := msg.Root()
	return View_reverse_Results(root.Struct()), err
}

func (s View_reverse_Results) String() string {
	str, _ := text.Marshal(0xcc7efefbb528cd6c, capnp.Struct(s))
	return str
}

func (s View_reverse_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_reverse_Results) DecodeFromPtr(p capnp.Ptr) View_reverse_Results {
	return View_reverse_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_reverse_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_reverse_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_reverse_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_reverse_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_reverse_Results) View() View {
	p, _ := capnp.Struct(s).Ptr(0)
	return View(p.Interface().Client())
}

func (s View_reverse_Results) HasView() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_reverse_Results) SetView(v View) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// View_reverse_Results_List is a list of View_reverse_Results.
type View_reverse_Results_List = capnp.StructList[View_reverse_Results]

// NewView_reverse_Results creates a new list of View_reverse_Results.
func NewView_reverse_Results_List(s *capnp.Segment, sz int32) (View_reverse_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[View_reverse_Results](l), err
}

// View_reverse_Results_Future is a wrapper for a View_reverse_Results promised by a client call.
type View_reverse_Results_Future struct{ *capnp.Future }

func (f View_reverse_Results_Future) Struct() (View_reverse_Results, error) {
	p, err := f.Future.Ptr()
	return View_reverse_Results(p.Struct()), err
}
func (p View_reverse_Results_Future) View() View {
	return View(p.Future.Field(0, nil).Client())
}

const schema_fcf6ac08e448a6ac = "x\xda\xacV]l\x1cW\x15>\xe7\xdeu\xc6\xf6\xfe" +
	"\xcc\\\x8f\x0biQ\xb5M\x88\xc1Yd+?\x05)" +
	"V\xabuL,;Q#\xf9\xc6\x09\"\xa5\x02\xc6\xeb" +
	"[\xef\xc0\xec\xac;3\x8e\x8dD1U\x0b*)\x7f" +
	"\x15 \xb5\x91(\x08H\xa1P\xa9\x8a%\x0a\xad\x02\x02" +
	"\x1eZ\x81\x9c\x02\x05\x15\x19!\xa5\xa9(\x15\x0f\xb4\xb6" +
	"ESj\x8c\x07\xdd\xf9\xd9\x19{\xd7\xe6\x85\xb7\xeb\xf1" +
	"\xd9{\xbe\xf3\x9d\xef|\xe7\x1e8\xdf6\x989\x98\xff" +
	"~7\x10\xbe\xdc\xb6\xcb\xbf\xb0o\xfd\xce\xc3\xcb7\x9f" +
	"\x07V\xa0\xfe\x93\x8f\x8f\xfe\xb5\xfd\xc9\xeb\xeb\x00\xa8\x1f" +
	"\xe9\xbc\xa0\x1f\xed\x9c\x02\xd0\x1f\xee|^\xef\xc8*\x00" +
	"~\xdf\xe8\xd5\x95\xfb\x97\x8a\x0f\x01\xd3\x11 \xa3\x00\x1c" +
	"^\xe9\xecB\xc8\xf8?{\xec\x89\xa7_\xa8=\xf3e" +
	"`\xefB\x806\x94\xffZ\xea\x1c@@\xfdZg\x19" +
	"\xd0\xbf\xe5\xad\x0f<\xa2\xdc\xe3=\x01\xbc\x80$I\xd4" +
	"F\x14\x00\x1d\xb3\xbf\x0a3\xe8m\xd9\xd7\x00\xfd\xf1\xc5" +
	"\xeb\x13\xb7\xdc\xae\xff\x08\xb8\x8e$\x818\x8c\x0a\xc1\x8c" +
	"\xfe\xf7\xec\xaa\xfef\x10\xbd\x92\x9d\x05\xf4\xcf\xff\xbe\xeb" +
	"'o}\x8b,\xc8h\xdc\x14M\x01\xf4\x93\xb9W\xf4" +
	"\xb39\x19}&\xf7\x14\xa0\xff\xde\x91]\x7fxG\xae" +
	"g\x01\xd8\x0d\x0d\xa4\xff\xc8uJ\xa4o\xe6$\xd2\x8b" +
	"\xd7\xff\xf8\x9e\xc5L\xdfb\xf3u\x19D\xfd\xc6\xfco" +
	"\xf4\x9e\xbc\xfc\xd1\x9e|\x11\x01}\xebJ\xef\x8f\xff\xbd" +
	"\xf1\x99\xc5\x90\x93\xf0\xbe\x83\x85\x9b\xe4}G\x0aA\xe5" +
	"\xf7\x8e/\xfc|\xe8\xb7W\xb6\x14\x13V~\xb6\xf0\xa2" +
	".\x0a\xf2d\x14d\xe5\x97{\xf1\xf9\x87\xee\xfa\xe6K" +
	"\xcd\xedP\x9f\xd5\x8f\xaa2\xf0vuD\x17\xf2\xe4g" +
	"\xde]\xb8\xfc\xc8\xea\xf7^jFJd\xe1\xea\x9a~" +
	"6\xf8\xc5\x19U\xd2d\xf5\xbe\xef_\xa7_\xde\xbf\x14" +
	"\x01\x95\xe9\x0f_R\x83\xc2\x9f\x09\x02\xd6v\x7f\xe5\xe1" +
	"\xdbV\xde~\x19X\x01S\x1d\xa2\xf2\x8a>mA\x7f" +
	"\xbf&O\x075\xc9\xe2\x1b\x7f*>}l\xf1\xc4\xab" +
	")%\\\xd1\x88T\x82\xbe\xfe\x83\x91.\xe3\xea\xdf\xd2" +
	"|\\\xd2\xba\x824\x9a\xe4\x83\xde\xf6\x9d\x85\xca\xe3_" +
	"{\x1d\x98N\x13\xd0\x80\xfa\x92\xf6g\xfd\xd5 \xc75" +
	"mD\xef`\x0a\xc0\xd5\xd7\xd6\xfe\xf2\x9c\x93]N\xf5" +
	"j%\xbc\xeb\xed\xe0\xae\x8d\xa9\xc2\xeb\xa7?\xf2\xd82" +
	"\xb0w6\x02nd%\x19\xb0\x87\xc9\x80\xcb\xab\xbf|" +
	"\xe1\xd8\xb5\xd5\x95&>\x8f\xb2\x1f\xea\xc7e\x0a}\x98" +
	"\x8d\xe85y\xda\x18\xbc\xf5\xd7g.~\xe3\x9f!\xf0" +
	"\xa0\xec3l\x0dP?\xcbd\xc9\xbf{t\xfe\xa7\xf7" +
	"\x7f\xbbw-\x9d\xab\xa3k\xaf\xcc\xc5\xba\xca\xe0\xc3w" +
	"\xfd\x8a5\xe3z\xc2\xe9\xc7\x8a1mO\x0f|\xc8\xa4" +
	"b\x96\xef\xc6t\xcd\xfb\x87\x12\xbd\xb2\x9e\x13\x89\xd4Y" +
	"\xcf\x9d\x89\xf4X\xcf\xa1D7l\xcf@\xd2jv\xf3" +
	"\xc4\xfc\xa8aOZ\xc2\xf1\xc7\x85%*^\xdd\x01\x00" +
	"\xff\x83u\xdb\xf5\x1c\xc3\x04j{\xc5\xe3\xf6\xa4\x98+" +
	"\x9f\x12\x95\xba3\xe9\x9f4>5!N\x89\x0a(u" +
	"g\x92\xe7h\x1b@C\x0b\x18w\x8b\xf1\x01 lX" +
	"A\x8cYH\xb5\xf8H\x09\x08\xebS\x904\x0c\x00c" +
	"\xd5\xb3=C@\xd8\x0dJ\xd9\xaa\xd7?93=\x88" +
	"\xaa\xe9\x09g\x10\xe7\x1dqN8\xae\x18\xc41\xc4\x06" +
	"/4\xe6E\xcc\xf6G\x01\xfb\xc6\x0c\xc7\xa8\xa1\xdb2" +
	"&*\xb4\xdf\x11\x95s\xfb\xcaA\xa4\xcb34\x03\x90" +
	"A\x00\x96\x1f\x00\xe0\xed\x14y7\xc1\xb2\x13T\x8bZ" +
	"\xc2\x1b j\x90$'\xe1\xc5\xa3\xc2p\xbc\x09ax" +
	"0\x86\xc8\xb5\xc6e\xc6^\x00~\x17E^%\xc8\x10" +
	"\xbbQ~\x142\xc3\xc7)r\x8b \x92n$\x00\xcc" +
	",\x01\xf0I\x8a|\x9a \xa3\xd8\x8d\x14\x80\xd5\xe4\xc7" +
	"*E\xfe\x00A\xc5\xf3,l\x07\x82\xed\x80eW8" +
	"\xe7\x84\x83\x1d@\xb0\x03P\xad\xd6]\x0fs@0\x07" +
	"\xa8\xd6\x84g`\x01p\x8cb\xf0\xad\xd0\x8c6\xa0!" +
	"\xe8m\xd11L\xdb\x93\x98\xdbi&\xe7\xfb\x01\xe8\xfd" +
	"\x87\x00\xf8>\x8a\xfc\x00\xc1<n\xf8!\xea\xbe\x9b\x00" +
	"x/E~+\xc1\xa2e\xd6L/\xceO\xbd:j" +
	"\x89\xccZ3\x14\xe4\x0c\xb4\xa5xuGf\xcc%\x19" +
	"\x87%M\x83\x14\xf9\x1d\xe9\x8c\xc7%\x8ec\x14\xf9\x18" +
	"\xc1<\xf9\x8f\x1f2uR\x922J\x91\x9f&\xa8\x18" +
	"\x96\x05\xbb\x8a5\xc3\xabT\x9b!\xa8w;\xf5\xda\x0e" +
	"\xc8\"Q\x8c\x9bS\xb6p\xfa]s\xca\x0eu\xe3\x02" +
	"\xa4\xf5p\x0a\x80\xe7(\xf2\xdd\x04\xfdJ\xd5\xb0,a" +
	"O\x01\x0a\xcc\x03\xc1\xfc6\x85\x06\xb3\x02\x81\x18\xba\x1b" +
	"7\xdd+\xfb>\x17\xb63\x8f~T\xe5}\xb2\x9eO" +
	"S\xe4\x0f\xca*7\xa2*?'c?K\x91\x7f\x91" +
	"`\x9e\xca\xda\xa5 \xbe c\x1f\xa0\xc8\xbfJ0\x9f" +
	"Y\xf7\xbb1\x03\xc0\xbe$\xbf>H\x91\x7f\x9d`y" +
	"\xda\x11w\x9bs\x88@\x10\x01\xd5i!\x9cX\x1a\xb1" +
	"l\"\xe0-d\x13\xfd\xb1\xe3h\x9d\x12\xee\x8cE\xbd" +
	"M#SJFF=g\x8aYdi\x0fF\xb6\x0d" +
	"K\x81\x97\xe0\xe4\x96\x91)%#\xd3jb\x18\xc1h" +
	"d\xf6\xb6\x1a\x19\xd9-\x8b\"\x9f#\xad\x8b\x8f4\xab" +
	"\xb8\xe2\x9e\xf8\xecW\xa3\xe9\x05\xf4\xe4\xa8\xc7\x8f\x8a-" +
	"r\x89\xfc\xf7\xb4(;5\xd36,\x09;\x13\x18_" +
	"l\xe2\x18o\x0e\xc6\x0e\x01amJ\xd1\xaaO\x99\xf6" +
	"f\xbbJ\x13\x10\xb8hd\xa9[\x87p\xa8\xe5\x10\x96" +
	"\x92!\x9c\xb7\xeb^\xd5\xb4\xa7`\x97\xfa\x89\x19\xd7\xdb" +
	"\xc1\xa4\xd2m\x0c-5\x11z{\x83\xf8\xfd'\x92\xbb" +
	"\x1b^up\x02\x80\x1f\x08'\xd3w\x93\xd5\x80Z\xb2" +
	"q\xe2l\xf1\xb2Pl\xcf\x8d\x1dHKv\x11\xe0&" +
	"/\x8a\xe8\x1c\x17E\xd75\xebv\xe4\x08\x11\x96\xe1R" +
	"b\x08\x0d,\xc7K\x89\x1f0\x12\x19\xe7I\x89\xfa\x0e" +
	"\x8a\xfc\xc3\xdbjO\x15s\xa2\x82\xcc\x7fq\xe6\xbe\x8b" +
	"\xcf~\xb4\xff\xa9\x86$\x8d\xe9q\xaf\xee\x08Y\x0e\xf3" +
	"\x9f\x1b~\xe3\xfc\xe7\xb3\x17_\xd9*X%E\x9e\\" +
	"C\xe1\x00x.\xc4\x01\xcd\xe4\x86\x11\xb8\xc3V\x09\xfe" +
	"\xaf%\x0bx\x07\xcf\x0c\xd6\x15\x15N\"\xb7\xf8Y\x8c" +
	"\xf6\xa5_\xcc\x1e\xbe\xf0\xb1G\x19+\x05rS\xe5J" +
	"k\xb9\x1c\xd3\x1e\xf7\xbf\xd0\xc9 1\xd9do4\x96" +
	"\x7f\xa8\xfe\xfe@\xda\xf22U\xb2\x91\xbel(\xb9l" +
	"\xde\x15AwQK\x1e\x82\xad\xc7j\xdcT%\xc4\xa4" +
	"\xca\xf8I\x8d\xc1k\x0d\xb2\xcb\x8d*%\xc0\xedg*" +
	"\xe8Q\xbc\xd6S\x8a\x1aj\xa5\xa8\x13\xc9.i(\x8a" +
	"K\xc9\x8f\x85f3_\x0d\x1f\x0b\xc8\x92\xd7V\xa4\x8f" +
	"\xff\xeb0\xb4&w\xccp\x94-\x8f\x934\xb7F\xa5" +
	"R\x9f\xb1=d\xc9\x834\xc4\xf6\xdf\x00\x00\x00\xff\xff" +
	"A,\xae\xd4"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_fcf6ac08e448a6ac,
		Nodes: []uint64{
			0x8a1df0335afc249a,
			0x8b1fd983f1df482d,
			0x8eb96dceb6a99ebd,
			0xa97471079836f720,
			0xab133d2062f6cc53,
			0xb2029ff7b712d18a,
			0xb2250c16d3064727,
			0xcc2d04cc26d4f6a5,
			0xcc7efefbb528cd6c,
			0xcdcf42beb2537d20,
			0xd69d5c8bc70128bc,
			0xd6a4f298bc0e2304,
			0xd929e054f82b286c,
			0xe0f9f13c918f18fa,
			0xe54acc44b61fd7ef,
			0xe6df611247a8fc13,
			0xee93a663b2a23c03,
			0xf00b0072c6dcfae7,
			0xf09e5b54ee0e67fe,
			0xf1f2e144cec1f2bc,
			0xf495a555c9344000,
			0xfa28a083b87f99d0,
		},
		Compressed: true,
	})
}
